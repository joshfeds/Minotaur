Problem 1:

The strategy I devised was to designate one of the guests as the leader. The leader is tasked with counting every empty plate that he sees and then replacing it with a cupcake. The other guests are to only eat a cupcake once and if there is already one on the plate. Once the number of empty plates equals the number of guests, the leader then knows that everyone has entered the room at least once and announces it as so. This strategy is guaranteed to work because there is only one person replacing empty plates (the leader), and everyone agrees to only eat one cupcake. This ensures that the leader can count how many unique guests have been in the labyrinth. In 10 tests of the program, 52 guests on average entered the labyrinth, with a total of 10 unique guests. While it's hard to be efficient when guests are randomly selected, the previous steps taken ensure that once the condition is met (and the leader is aware of this), there are no more people going through the labyrinth. In my experimentation of the project, I struggled to figure out how to meet the conditions of the problem. My first strategy was to get everyone to count the number of empty plates, although I realized that if a person was called in back to back, they wouldn't know that the empty plate did not change, meaning they would be misinformed. I also wasn't sure how to keep people out of the labyrinth, until I began utilizing semaphores to only go through the loop one thread at a time. 

Problem 2:

Of the three strategies, I found the third one to be the fairest to implement. Guests queue themselves into the line to view it at least once. If they want to see it again, they go to the back of the line and wait for their turn. This solves the issue with solution 1 (too many people crowding around the door to watch) and solution 2 (no set rule for which guest can go in once it is available, meaning a guest could hog up plenty of timeslots without any regard for the other guests). A possible disadvantage of utilizing the queue is that the line of guests could be long. However, when a guest is done viewing the jewel, they could decide to not view it again because the line was too long (not from a coding standpoint, but rather a practical). Strategy 3 dictates that guests are allowed to queue up multiple times and that everyone should view the jewel at least once. To implement this, I inserted every guest into a queue, popping the head once they have visited. After that, the guest makes a 50/50 decision on whether they want to view the jewel again or not. If so, they reenter the queue and wait their turn. Once everyone is satisfied with viewing the jewel (queue is now empty), I break the loop that checks if a given guest is done waiting in line. Similar to problem 1, I utilized semaphores to ensure that only one guest enters the showroom at a time. In my project, I struggled at first with when to unlock the showroom, especially once the queue was empty. I then realized that I needed to release the lock once the queue was empty so that the thread could eventually end.
