Problem 1:

The strategy I devised was to designate one of the guests as the leader. The leader is tasked with counting every empty plate that he sees and then replacing it with a cupcake. The other guests are to only eat a cupcake once and if there is already one on the plate. Once the number of empty plates equals the number of guests, the leader then knows that everyone has entered the room at least once and announces it as so. This strategy is guaranteed to work because there is only one person replacing empty plates (the leader), and everyone agrees to only eat one cupcake. This ensures that the leader can count how many unique guests have been in the labyrinth. In 10 tests of the program, 52 guests on average entered the labyrinth, with a total of 10 unique guests. While it's hard to be efficient when guests are randomly selected, the previous steps taken ensure that once the condition is met (and the leader is aware of this), there are no more people going through the labyrinth. In my experimentation of the project, I struggled to figure out how to meet the conditions of the problem. My first strategy was to get everyone to count the number of empty plates, although I realized that if a person was called in back to back, they wouldn't know that the empty plate did not change, meaning they would be misinformed. I also wasn't sure how to keep people out of the labyrinth, until I began utilizing semaphores to only go through the loop one thread at a time. 

Problem 2:

Of the three strategies, I found the third one to be the fairest to implement. Guests queue themselves into the line to view it at least once. If they want to see it again, they go to the back of the line and wait for their turn. This solves the issue with solution 1 (too many people crowding around the door to watch) and solution 2 (no set rule for which guest can go in once it is available, meaning a guest could hog up plenty of timeslots without any regard for the other guests). A disadvantage of the queue is that it requires more effort to maintain properly so that guests don't go out of order, at least compared to other strategies where the order of guests is not important. Strategy 3 dictates that guests are allowed to queue up multiple times and that everyone should view the jewel at least once. To implement this, I inserted every guest into a queue, popping the head once they have visited. After that, the guest makes a 50/50 decision on whether they want to view the jewel again or not. If so, they reenter the queue and wait their turn. Once everyone is satisfied with viewing the jewel (queue is now empty), I break the loop that checks if a given guest is done waiting in line and set the empty queue variable to false so all the other threads know to also exit. Instead of using a sephamore for this problem, I chose to use a lock and an array of conditions. When I was using the sephamore, I found it a challenge to maintain the queue, as it would often repeat the guests in a fashion similar to that of strategy 2. With lock and conditions, I was able to signal the proper thread to enter the room and view the jewel. In terms of overall efficiency, the initial goal of everyone entering the room is O(n), as no guest can cut the line. The length of the program mainly depends on how many people view the jewel multiple times. 
